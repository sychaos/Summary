Java类加载器的加载流程。
类加载器，双亲机制，Android的类加载器。
JVM的内存模型
JVM 内存区域 开线程影响哪块内存
垃圾收集机制 对象创建，新生代与老年代
垃圾回收机制与调用System.gc()区别
强引用置为null，会不会被回收？
gc！！

## ClassLoader 原理

## 双亲委托机制
双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，
如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，
倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，
即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊？那么采用这种模式有啥用呢?

## 类的五个加载过程。（不够详细）
 1. 加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象
 1. 验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
 1. 准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，
 这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
 1. 解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
 有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。
 1. 初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。

## 类的加载过程，Person person = new Person();为例进行说明。 TODO
1. 因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;
2. 执行该类中的static代码块，如果有的话，给Person.class类进行初始化;
3. 在堆内存中开辟空间分配内存地址;
4. 在堆内存中建立对象的特有属性，并进行默认初始化;
5. 对属性进行显示初始化;
6. 对对象进行构造代码块初始化;
7. 对对象进行与之对应的构造函数进行初始化;
8. 将内存地址付给栈内存中的p变量
