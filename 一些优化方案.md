# 一些优化方案

## 过渡绘制 TODO 待完善：
### 概念
* 过渡绘制是指在屏幕一个像素上绘制多次(超过一次)。比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。
* 蓝色1x过度绘制，绿色2x过度绘制，淡红色3x过度绘制，红色超过4x过度绘制

### 产生原因
* 冗余的背景
* 嵌套的layout

### 处理方案
* 减少多余的background
* 减少层级
* this.getWindow().setBackgroundDrawable(null);的方式去设置背景，这个要谨慎使用，在低端机上的使用可能会造成闪屏的情况，
* 动态地inflation view性能要比setVisible性能要好.当然用ViewStub是最好的选择.（ViewStub怎么用）
* 内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。
在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建.所以要尽量避免使用Layout_weight

下拉ListView的实现，需要注意的地方和优化的地方（不是ListView的优化，是下拉的优化）。TODO

## Android怎么加速启动Activity：
* 减少主线程阻塞时间(减少主线程耗时操作)
* 优化布局文件

## Android性能优化方法
* 布局优化：尽量减少布局文件的层级
    * 删除布局中无用的控件和层次，有选择的使用性能较低的 ViewGroup
    * 采用标签，ViewStub，布局重用可降低布局的层级（ViewStub提供了按需加载的功能，当需要时才会将 ViewStub 中布局加载到内存，提高了初始化效率）
    * 避免过度绘制
* 绘制优化：View 的 onDraw() 方法避免执行大量操作。
    * onDraw() 中不要创建新的布局对象。
    * onDraw() 中不做耗时任务，大量循环十分抢占 cpu 时间片，造成 View 的绘制不流畅。
* 内存泄漏优化
    * 避免写出内存泄漏代码
    * 通过分析工具（MAT、LeakCanary）找出潜在的内存泄漏方法，然后解决。
    导致内存泄漏的原因:
    集合类的泄漏（循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。）
    单例 / 静态变量造成内存泄漏
    匿名内部类/非静态内部类造成内存泄漏
    资源未关闭
* 响应速度的优化：避免在主线程做耗时的操作。
* ListView / RecyclerView优化：
    * 使用 ViewHolder 模式来提高效率
    * 异步加载：耗时操作放在异步线程
    * 滑动时停止加载和分页加载
* 线程优化：采用线程池，避免程序中存在大量 Thread 。
* 其他性能优化：
    不要过多的创建对象。
    不要过多使用枚举类，枚举占用内存空间要比整型大。
    常量使用 static final 修饰。
    使用 Android 特有的数据结构。
    适当采用软引用和弱引用。
    采用内存缓存和磁盘缓存。
    尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。

## Android中软引用与弱引用的应用场景。 TODO

