# 在多进程中，Application会启动几次
    由于应用每启动一个新的进程，就会调用一次Application的onCreate()方法

    进程与线程
    进程状态
    进程调度
    进程和线程的区别。Android中多进程，修改静态变量的值会怎么样
    进程间通信方式。管道和Socket有什么区别？共享内存和Socket分别会用在什么情况下？

# Android进程级别
    * 前台进程
    用户当前正在做的事情需要这个进程。如果满足下面的条件之一，一个进程就被认为是前台进程：
    1).这个进程拥有一个正在与用户交互的Activity(这个Activity的onResume()方法被调用)。
    2).这个进程拥有一个绑定到正在与用户交互的activity上的Service。
    3).这个进程拥有一个前台运行的Service（service调用了方法startForeground()）.
    4).这个进程拥有一个正在执行其任何一个生命周期回调方法（onCreate(),onStart(),或onDestroy()）的Service。
    5).这个进程拥有正在执行其onReceive()方法的BroadcastReceiver。
        通常，在任何时间点，只有很少的前台进程存在。它们只有在达到无法调合的矛盾时才会被杀－－如内存太小而不能继续运行时。通常，到了这时，设备就达到了一个内存分页调度状态，所以需要杀一些前台进程来保证用户界面的反应.

    * 可见进程
    一个进程不拥有运行于前台的组件，但是依然能影响用户所见。满足下列条件时，进程即为可见：
    这个进程拥有一个不在前台但仍可见的Activity(它的onPause()方法被调用)。当一个前台activity启动一个对话框时，就出了这种情况。

    * 服务进程
    一个可见进程被认为是极其重要的。并且，除非只有杀掉它才可以保证所有前台进程的运行，否则是不能动它的。
    这个进程拥有一个绑定到可见activity的Service。
    一个进程不在上述两种之内，但它运行着一个被startService()所启动的service。
    尽管一个服务进程不直接影响用户所见，但是它们通常做一些用户关心的事情（比如播放音乐或下载数据），所以系统不到前台进程和可见进程活不下去时不会杀它。

    * 后台进程
    一个进程拥有一个当前不可见的activity(activity的onStop()方法被调用)。
    这样的进程们不会直接影响到用户体验，所以系统可以在任意时刻杀了它们从而为前台、可见、以及服务进程们提供存储空间。
    通常有很多后台进程在运行。它们被保存在一个LRU(最近最少使用)列表中来确保拥有最近刚被看到的activity的进程最后被杀。
    如果一个activity正确的实现了它的生命周期方法，并保存了它的当前状态，那么杀死它的进程将不会对用户的可视化体验造成影响。因为当用户返回到这个activity时，这个activity会恢复它所有的可见状态。

    * 空进程
    一个进程不拥有入何active组件。
    保留这类进程的唯一理由是高速缓存，这样可以提高下一次一个组件要运行它时的启动速度。系统经常为了平衡在进程高速缓存和底层的内核高速缓存之间的整体系统资源而杀死它们。

# 如何让服务不被杀死？

* Service设置成START_STICKY kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样

* 通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别​，除非在系统内存非常缺，否则此进程不会被 kill

* 双进程Service： 让2个进程互相保护**，其中一个Service被清理后，另外没被清理的进程可以立即重启进程

* QQ黑科技: 在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死

* 在已经root的设备下，修改相应的权限文件,将App伪装成系统级的应用 Android4.0系列的一个漏洞，已经确认可行

* 用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响。
    鉴于目前提到的在Android->- Service层做双守护都会失败，我们可以fork出c进程，多进程守护。死循环在那检查是否还存在，具体的思路如下（Android5.0以上的版本不可行）

* 用C编写守护进程(即子进程)，守护进程做的事情就是循环检查目标进程是否存在，不存在则启动它。
    在NDK环境中将1中编写的C代码编译打包成可执行文件(BUILD_EXECUTABLE)。主进程启动时将守护进程放入私有目录下，赋予可执行权限，启动它即可。

* 联系厂商，加入白名单

# 多进程
    Android中多进程是指一个应用中存在多个进程的情况

# 多进程场景遇见过么
    一款音乐播放器
        * 在Activity中直接播放音乐。
        * 启动后台Service，播放音乐。
        * 启动前台Service，播放音乐。
        * 在新的进程中，启动后台Service，播放音乐。
        * 在新的进程中，启动前台Service，播放音乐。

    多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），
    还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。
    首先多进程开发能为应用解决了OOM问题，Android对内存的限制是针对于进程的，
    这个阈值可以是48M、24M、16M等，视机型而定，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。

# Linux中进程A能否直接访问进程B？为什么不能？
    当然不能
    理由：
